<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Shooter Sniper</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #mobileControls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    .btn { 
      width: 50px; height: 50px; background: rgba(0,0,0,0.5); 
      color: white; font-size: 20px; text-align: center; line-height: 50px; 
      border-radius: 50%;
      user-select: none;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      margin-left: -5px;
      margin-top: -5px;
      border: 2px solid white;
      border-radius: 50%;
    }
  </style>
</head>
<body>
<div id="mobileControls">
  <div class="btn" id="up">↑</div>
  <div class="btn" id="down">↓</div>
  <div class="btn" id="left">←</div>
  <div class="btn" id="right">→</div>
  <div class="btn" id="jump">⤴</div>
</div>
<div id="crosshair"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.164.0/examples/js/controls/PointerLockControls.js"></script>

<script>
let scene, camera, renderer, controls;
let player = { speed: 0.2, jump: 0.3, yVelocity: 0, onGround: true };
let keys = {};
let targets = [];
let obstacles = [];

init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // langit biru

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const floorGeometry = new THREE.PlaneGeometry(100, 100);
    const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const directional = new THREE.DirectionalLight(0xffffff, 0.8);
    directional.position.set(5,10,7);
    scene.add(directional);

    controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => controls.lock());

    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    const btns = ['up','down','left','right','jump'];
    btns.forEach(id => {
      document.getElementById(id).addEventListener('touchstart', () => keys[id] = true);
      document.getElementById(id).addEventListener('touchend', () => keys[id] = false);
    });

    // Target & Obstacle
    const targetPositions = [10,20,30,40,50,60];
    targetPositions.forEach(x => {
        const geometry = new THREE.BoxGeometry(1,1,1);
        const material = new THREE.MeshPhongMaterial({color: 0xff0000});
        const target = new THREE.Mesh(geometry, material);
        target.position.set(x, 0.5, -5);
        target.health = 100; // HP target
        scene.add(target);
        targets.push(target);

        const obsGeo = new THREE.BoxGeometry(2,2,1);
        const obsMat = new THREE.MeshPhongMaterial({color:0x888888});
        const obs = new THREE.Mesh(obsGeo, obsMat);
        obs.position.set(x-5,1, -5);
        scene.add(obs);
        obstacles.push(obs);
    });

    window.addEventListener('resize', onWindowResize);

    // Mouse click untuk tembak
    window.addEventListener('mousedown', shoot);
}

function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function shoot(){
    // Raycast dari center kamera
    const raycaster = new THREE.Raycaster();
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    raycaster.set(camera.position, dir);

    const intersects = raycaster.intersectObjects(targets);
    if(intersects.length > 0){
        const hitTarget = intersects[0].object;
        hitTarget.health -= 100; // AWM hit = 100
        if(hitTarget.health <= 0){
            scene.remove(hitTarget);
            targets.splice(targets.indexOf(hitTarget),1);
        }
    }
}

function animate(){
    requestAnimationFrame(animate);

    // Movement
    let dir = new THREE.Vector3();
    if(keys['w'] || keys['up']) dir.z -= 1;
    if(keys['s'] || keys['down']) dir.z += 1;
    if(keys['a'] || keys['left']) dir.x -= 1;
    if(keys['d'] || keys['right']) dir.x += 1;

    dir.normalize();
    dir.multiplyScalar(player.speed);

    controls.moveRight(dir.x);
    controls.moveForward(dir.z);

    if(keys[' ' ] || keys['jump']) {
        if(player.onGround){
            player.yVelocity = player.jump;
            player.onGround = false;
        }
    }
    player.yVelocity -= 0.01; // gravity
    camera.position.y += player.yVelocity;
    if(camera.position.y < 1.6){ 
        camera.position.y = 1.6; 
        player.yVelocity = 0;
        player.onGround = true;
    }

    renderer.render(scene, camera);
}
</script>
</body>
</html>
